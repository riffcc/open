<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thought Network</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script>
        let thoughts = [];
        let zoomFactor = 1;
        let offsetX = 0, offsetY = 0;
        let dragStartX, dragStartY;
        let isDragging = false;

        function setup() {
            createCanvas(windowWidth, windowHeight);
            let socket = io.connect(window.location.origin);

            socket.on('network_update', (data) => {
                thoughts = data.thoughts;
            });

            // Panning with mouse drag
            canvas.addEventListener('mousedown', (event) => {
                dragStartX = event.clientX;
                dragStartY = event.clientY;
                isDragging = true;
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });

            canvas.addEventListener('mousemove', (event) => {
                if (isDragging) {
                    offsetX += (event.clientX - dragStartX) / zoomFactor;
                    offsetY += (event.clientY - dragStartY) / zoomFactor;
                    dragStartX = event.clientX;
                    dragStartY = event.clientY;
                }
            });

            // Zooming with mouse wheel
            canvas.addEventListener('wheel', (event) => {
                let zoomSensitivity = 0.001;
                let zoomDelta = event.deltaY * zoomSensitivity;
                let newZoom = zoomFactor * (1 - zoomDelta);

                // Zoom about the mouse position
                let mx = (mouseX - offsetX) / zoomFactor;
                let my = (mouseY - offsetY) / zoomFactor;

                offsetX -= mx * (newZoom - zoomFactor);
                offsetY -= my * (newZoom - zoomFactor);

                zoomFactor = newZoom;
            });
        }

        function draw() {
            background(255);
            scale(zoomFactor);
            translate(offsetX, offsetY);
            drawThoughts();
        }

        function drawThoughts() {
            for (let thought of thoughts) {
                // Draw connections
                for (let connectionId of thought.connections) {
                    let target = thoughts.find(t => t.id === connectionId);
                    if (target) {
                        stroke(0, 100);
                        line(thought.x, thought.y, target.x, target.y);
                    }
                }

                // Draw thoughts
                fill(thought.color);
                noStroke();
                ellipse(thought.x, thought.y, thought.radius * 2);
                
                fill(0);
                textAlign(CENTER, CENTER);
                text(thought.concept, thought.x, thought.y);
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</body>
</html>
